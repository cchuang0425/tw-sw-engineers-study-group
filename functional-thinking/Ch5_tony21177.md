# Chapter 5 Review

此章探討函數式和物件導向面對自定義結構的差別

## 數據結構和操作

* OOP鼓勵針對問題建立專門的數據結構(class),並以方法(method)的形式去關聯操作,而函數式用很少的數據結構(e.g. list,map,set)和一些高度優化過的高階函數來適應問題,也就是函數式把封裝的單元縮小到函數級別
  * 解析XML - JAVA的SAX、DOM而Closure只用map搭配各式的高階函數操作
   
* 讓語言去迎合問題這節,書上提到一個我完全沒有想過的觀點,非常有趣  
  * 很多開發者會把複雜的業務問題翻譯成程式語言如Java;但另外幾種語言則是設法去迎合問題,達成靈活的[DSL](https://zh.wikipedia.org/wiki/%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80)設計

## 分發機制(動態的選擇行為)

* Java要表達條件執行時,大多用if語句,通常也會使用Factory pattern來取代長串的if問題,但有些語言提供更靈活的方式來表達複雜的判斷
  * Groovy的switch允許動態類型也允許區間、正則表達式
* Closure允許根據問題來創造語言,比如書上例子定義in然後利用cond函數來作分發
* 而Java不可以自創新的關鍵字,只能創建類別和方法,這就造成使用Java時需把問題翻譯成Java語言的描述
* 物件導向語言如Java利用繼承和多型而非物件導向語言的Closure則利用多重方法(multimethod)來達到分發機制

##  運算符重載

* 可利用運算符重載來契合問題領域的習慣,Groovy,Scala都有提供運算符重載

## 函數式的數據結構

* Either在異常處理的應用
  * Java的異常處理違背了函數式語言的條件,拋出異常本身就是一種副作用,函數式以操作值為根本,所以喜歡在返回值表明錯誤,這樣就不需打斷程序的一般流程
  * 為了拋棄原有Java異常處理的機制,利用Java的Map<String,Object> 來返回多個值(正確結果和異常)的設計,都有兩個缺點
    * 沒有類型權的保障
    * 使用者需要逐一比對所有key
    * 無法強制return的map只有一對鍵值
  * 針對上點來考慮,函數式提供了Either來處理(其設計為要不左值就是右值,不會同時兩者並存),C也有類似的union;Scala提供了Either的實踐,除了利用在錯誤處理,在模式匹配上更是配合得很好
  * Java也可以利用泛型來模擬出Either類別的實現,比起用Map多了幾個好處
    * 類型安全
    * 返回結果多了一到間接層(需從Either提取結果),這樣的設計可以實現緩求值
  * Option可以看成是Either的一個子集,一般只拿來表示成功或失敗(成功返回或不存在有效值),例如Functional Java的option實現取值為none()或some()
* Either除了異常處理外的應用
  * 提供默認值
  * 模式匹配
    * 從Scala的case類搭配match來作模式匹配的例子來看,Java也可利用Either的設計來達成模式匹配的效果(書上利用Either模擬tree,遍歷tree的實現或是遞迴搜尋...等就很類似模式匹配的語法)