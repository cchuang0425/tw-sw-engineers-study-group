# 模式與重用

* 學習用不同範式的方式來解決問題,因為現代語言都是多範式的,不一定面對問題都要按照對象的術語去思考

## 函數語言中的設計模式

* 設計模式是賦予了名子的,記錄下來的常見問題解決方案,以此觀點來看,傳統的設計模式在函數式的世界有三種形式
  * 模式被吸收成為語言的一部分
  * 實現細節有所變化
  * 新的解決方案(例如許多函數式語言提供的元編程)
  
* 心得 - 傳統有些設計模式是為了增進靈活度(因為物件導向式語言的某些限制),反過來在函數式語言因為沒有了那麼嚴格的類別設計,這樣的設計模式當然就不需要在函數式存在;另外一些設計模式在函數式只是換了處理手法,畢竟一些問題不會因為換了函數式語言就不存在,因此個人認為慎重的思考問題的本質適合用哪種範式去處理是一個重點

## 函數級別的重用

* 函數式語言的composition是利用透過參數來傳遞函數來達成函數級別的重用
* 物件導向的設計模式和問題的狹窄對應限制了靈活性,而函數式語言的傳遞一級函數方式(連同其context一併傳遞)反而靈活
* 物件導向習慣構件類別和方法來解決問題,而函數式不需要這麼多自訂結構,例如有了閉包特性,就不需要物件導向的command模式(因為物件導向只有把command包裝成類別才能傳遞,而閉包可以連同函數和context一併傳遞),Template method模式在函數式也是直接以其語言特性(第一等函數)就可實現
* Strategy pattern在函數式也是直接以傳遞函數來實現,和OO的介面實作相比的差異是,介面規定了方法簽章,函數式的實現就比較靈活一點,兩者差異表現了靜態類型和動態類型思維的差異
* singleton直接在函數式語言被吸收(e.g. Groovy的＠singleton),OO的Flyweight在函數式直接以memoize實現即可,兩者模式在函數式都很輕易
* 函數式的currying可實現在OO的factory pattern,由此特性可看出函數式是很容易以第一等函數來輕易實現工廠模式以解決問題,反之來說,習慣命令式語言的開發者可能更傾向於使用特製結構和方法來解決問題

## 結構化重用和函數式重用的對比

* 物件導向封裝不確定性,而函數式盡量減少不確定性(減少side effect)
* 物件導向常使用couping來達到重用機制(e.g. extend)但往往只在少數方面適用(e.g.對象關係映射,圖形介面組件等),在那些物件導向不那麼明顯的領域,我們更應該從函數式的思維不用耦合而是用複合(composition)去解決問題

## 心得
* 其實設計模式很重要的一部份是為了程式碼重用,而物件導向和函數式程式碼重用的手段有所不同,個人經驗是物件導向因為類別的設計導致在解決問題時很難一眼看出程式碼結構和意圖,往往考驗開發者使用設計模式的功力,也很容易over design,這時候也許採用函數式的思維去解決更容易讓其他程式維護者清楚程式碼意圖,也更能減少物件導向在狀態變化的不確定所造成的Bug
