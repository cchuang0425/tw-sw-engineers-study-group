# Digest of Functional Thinking

## Chapter 1 & 2

### overview

如果要推薦一個人學習 functional programming，我覺得這本是個不錯的開始。然而，這本書適合已經有相當程度的 Java、C#、C++ 等物件導向語言經驗的人閱讀。作者針對函數式語言，做了一連串豐富的介紹，然而是著重在實務開發層面，並非理論層面，對於已經有相當程度開發經驗的人，會有許多幫助。

### 典範轉移

我在物件導向式的，或稱命令式的語言開發了十多年，我第一次開始接觸函數式的概念，是在學習 JavaScript 時，那時是 2013 年。但使用 JavaScript 的時期，函數僅僅是作為一個第一級物件(First class object)進行傳遞，並未真正地使用到函數式開發的精神。直到 2017 年時，開始研究 Scheme 語言，終於算是踏進了函數式編程。如同作者在第一章便直接地點明般，從命令式語言進入函數式語言，是一種典範的轉移(Paradigm Shift，書譯「範式轉變」)，原本在命令式語言裡，習以為常的迴圈結構，到了函數式語言裡面，卻變成一種很是精鍊的語法。例如加總數值：

```java
/*
* Java 的數值加總
*/

int sum(List<Integer> numbers){
	int sum = 0;
    for (int i=0; i<numbers.size(); i++){
        sum += numbers.get(i);
    }
    return sum;
}

void main(String[] args){
    List<Integer> numbers = Arrays.asList(1, 3, 5, 7, 9);
    int sum = sum(numbers);
}
```

```clojure
;; Clojure 的加總數值

(defn sum [numbers]
    (if (nil? numbers)
        0
        (+ (first numbers)
           (sum (rest numbers)))))

(sum (list 1 3 5 7 9))
```

作者在書裡面舉了一個更有趣的範例，我在此只是要說明語法表示上的差異。

各位，這是第一個問題， **我們何不來聊聊你們是否也經歷了這樣的典範轉移過程呢？**

### 思考方式的改變

作為程式員，我們很習慣把大的問題分解成小問題，化繁為簡，再一個一個小問題解決。在本書中，作者歸納了函數式的基本模式：篩選(filter)、映射(map)、折疊/化約(reduce)。

我在初學函數式開發時，曾經想過，實際上應該不只能用這三種方式吧？然而使用過 Java 的 API，使用過 Racket 之後，我發現萬變不離其宗，幾乎所有的函數式運作都以這三種操作為核心。

第二個問題，**我們來聊聊，在傳統的開發思維下，各位習慣怎麼使用自己的語言工具來進行這種工作呢？**

補充說明一下，我曾經讀過一篇，作者試用了各種 iterator 的方式來走訪一個大型的 collection，最後結論是 for 迴圈最快，沒有特殊理由，用 for 迴圈最好。然而，儘管存在者效率上的差別，我想更深一層的應該是程式閱讀性的差別，第二個問題可以延伸出來這樣問，**各位在 Java 或 C#、C++ 語境裡，究竟是偏好使用 for 迴圈呢？還是使用集合類別所提供的 for each 模式呢？**

### 回不去了怎麼辦

別擔心，剛開始學函數式開發，一定會覺得自己回不去了。拿了鏈鋸，看到什麼東西都想發動，然後好好地砍一砍。然而現實是，每個程式語言都有其限制，還有針對每種操作的優化與慣用寫法。例如 Python，有時候與其用 map，其實還有一個東西，叫 List Comprehension，帶著函數式的思維來寫 Python 時，會很習慣地使用 map 來做事，但 Python 的 map 其實是回傳一個 iterator，除非把它拆開，完全地走訪，不然它是不會執行的。因此，在寫 Python 時，常常需要回頭看自己的程式碼，這樣寫，對 Python 的 developer 好閱讀嗎？

各位，最後想與各位聊聊，讀完這第一章，或許對函數式的典範有些程度的理解，甚至各位在平常開發工作中已經有在使用了，**各位如何調適傳統命令式與函數式的寫法，以能夠在現行的開發情境中，既維持一定品質的程式碼可讀性，並與其他人達成溝通的目的呢？**
